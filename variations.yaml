common:
  r: length($v)
  rsq: $x * $x + $y * ($y)
  a: atan($x, $y)
  phi: atan($y, $x)
  sina: $x / $r
  cosa: $y / $r
  sinr: sin($r)
  cosr: cos($r)

  # [0,1] float depending on this thread's position in the
  # work group. essentially random from the perspective of
  # the particles given that the buffers are shuffled, but
  # do not expect any more than a precision of 1/block_size.
  # useful for making 50/50 splits without branching (see julia)
  lr: float(gl_LocalInvocationID.x)/float(gl_WorkGroupSize.x - 1)

variations:
  linear:
    result: ($v)

  sinusoidal:
    result: sin($v)

  spherical:
    result: $v / ($rsq + EPS)

  swirl:
    src: |-
      float c1 = sin($rsq);
      float c2 = cos($rsq);
    result: vec2(c1 * $x - c2 * $y, c2 * $x + c1 * $y)

  horseshoe:
    result: vec2(($x + $y) * ($x - $y), 2.0 * $x * $y) / ($r + EPS)

  polar:
    result: vec2($a / PI, $r - 1.0)

  handkerchief:
    result: $r * vec2(sin($a + $r), cos($a - $r))

  heart:
    result: $r * vec2(sin($r * $a), -cos($r * $a))

  disc:
    result: $a * vec2(sin($r * PI), cos($r * PI)) / PI

  spiral:
    result: vec2($cosa + $sinr, $sina - $cosr) / ($r + EPS)

  hyperbolic:
    result: vec2($sina/($r + EPS), $cosa * $r)

  diamond:
    result: vec2($sina * $cosr, $cosa * $sinr)

  ex:
    src: |-
      float n0 = sin($a + $r);
      float n1 = cos($a - $r);
      float m0 = n0 * n0 * n0 * $r;
      float m1 = n1 * n1 * n1 * $r;
    result: vec2(m0 + m1, m0 - m1)

  julia:
    # round($lr) * PI means that half of the threads in
    # this block will pick the first branch (0) and the other
    # half the second (PI). quicker than a if, ternary, or randf
    result: "sqrt($r) * sincos(0.5 * $a + round($lr) * PI).yx"

  bent:
    result: |-
      vec2(
        ($x < 0.0)? 2.0 * $x: $x,
        ($y < 0.0)? $y / 2.0: $y
      )

  waves:
    result: |-
      vec2(
        $x + $c10 * sin($y/($c20 * $c20 + EPS)),
        $y + $c11 * sin($x/($c21 * $c21 + EPS))
      )

  fisheye:
    result: 2.0 / ($r + 1.0) * vec2($y,$x)

  popcorn:
    result: |-
      vec2(
        $x + $c20 * sin(tan(3 * $y)),
        $y + $c21 * sin(tan(3 * $x))
      )

  exponential:
    result: exp($x - 1) * sincos(PI * $y).yx

  power:
    result: pow($r, $sina) * vec2($cosa, $sina)

  cosine:
    result: vec2(cos(PI * $x) * cosh($y), -sin(PI * $x) * sinh($y))

  rings:
    src: |-
      float rings_dx = $c20 * $c20 + EPS;
    result: (mod2($r + rings_dx, 2.0 * rings_dx) - rings_dx + $r * (1.0 - rings_dx)) * vec2($cosa, $sina)

  fan:
    src: |-
      float fan_dx = PI * ($c20 * $c20 + EPS);
      float fan_dx2 = fan_dx * 0.5;
      float fan_a = $a;
      fan_a += (mod2(fan_a+$c21,fan_dx) > fan_dx2) ? -fan_dx2 : fan_dx2;
    result: $r * sincos(fan_a).yx

  blob:
    param: 
      blob_high: {}
      blob_low: {}
      blob_waves: {}
    result: $r * ($blob_low + ($blob_high - $blob_low) * (0.5 + 0.5 * sin($blob_waves * $a))) * vec2($sina, $cosa)
      
  pdj:
    param:
      pdj_a: {}
      pdj_b: {}
      pdj_c: {}
      pdj_d: {}
    result: |-
      vec2(
        sin($pdj_a * $y) - cos($pdj_b * $x),
        sin($pdj_c * $x) - cos($pdj_d * $y)
      )

  fan2:
    param:
      fan2_x: {}
      fan2_y: {}
    src: |-
      float fan2_dx = PI * ($fan2_x * $fan2_x + EPS);
      float fan2_dx2 = 0.5 * fan2_dx;
      float fan2_a = $a;
      float fan2_t = $a + $fan2_y - fan2_dx * floor(($a + $fan2_y)/fan2_dx);
      if(fan2_t > fan2_dx2) 
        fan2_a = fan2_a - fan2_dx2;
        else fan2_a = fan2_a + fan2_dx2;
    result: $r * sincos(fan2_a)

  rings2:
    param:
      rings2_val: {}
    src: |-
      float rings2_dx = $rings2_val * $rings2_val + EPS;
      float rings2_r = $r;
      rings2_r += -2.0 * rings2_dx * float(int((rings2_r + rings2_dx)/(2.0 * rings2_dx))) + rings2_r * (1.0 - rings2_dx);
    result: rings2_r * vec2($sina, $cosa)

  eyefish:
    result: 2.0 / ($r + 1.0) * ($v)

  bubble:
    result: ($v)/(0.25 * $rsq + 1.0)

  perspective:
    param:
      perspective_angle: {}
      perspective_dist: {}
    result: |-
      vec2($x * $perspective_dist, $perspective_dist * cos($perspective_angle) * $y) 
      / ($perspective_dist - $y * sin($perspective_angle))

  noise:
    result: $v * randf() * sincos(randf() * 2.0 * PI).yx

  julian:
    param:
      julian_power: {}
      julian_dist: {}
    result: pow($rsq, $julian_dist / $julian_power / 2.0) * sincos(($phi + 2.0 * PI * trunc(abs($julian_power) * randf())) / $julian_power).yx

  juliascope:
    param:
      juliascope_power: {}
      juliascope_dist: {}
    src: |-
      int t_rnd = int(trunc(abs($juliascope_power) * randf()));
    result: |-
      pow($rsq, $juliascope_dist / $juliascope_power / 2.0)
      * sincos(
            (2 * PI * float(t_rnd) + (((t_rnd & 1) == 0)? 1: -1) * $phi)
            / $juliascope_power
        ).yx

  blur:
    result: randf() * sincos(randf() * 2.0 * PI).yx

  gaussian_blur:
    result: (randf() + randf() + randf() + randf() - 2.0) * sincos(randf() * 2.0 * PI).yx

  radial_blur:
    param:
      radial_blur_angle: {}
    flags: [no_weight_mul]
    src: |-
      vec2 radial_blur_spinzoom = sincos($radial_blur_angle * PI / 2.0);
      float radial_blur_rndg = $weight * (randf() + randf() + randf() + randf() - 2.0);
      vec2 tmpa = sincos($phi + radial_blur_spinzoom.x * radial_blur_rndg);
      float radial_blur_rz = radial_blur_spinzoom.y * radial_blur_rndg - 1.0;
    result: "vec2($r * tmpa.y + radial_blur_rz * $x, $r * tmpa.x + radial_blur_rz * $y)"

  pie:
    param:
      pie_slices: {}
      pie_rotation: {}
      pie_thickness: {}
    src: randf() * sincos($pie_rotation + 2.0 * PI * (trunc(randf() * $pie_slices + 0.5) + randf() * $pie_thickness)/$pie_slices)

  ngon:
    param:
      ngon_power: {}
      ngon_sides: {}
      ngon_corners: {}
      ngon_circle: {}
    src: |-
      float ngon_r_factor = pow($rsq, $ngon_power * 0.5);
      float ngon_b = 2.0 * PI / ($ngon_sides + EPS);
      float ngon_phi = $phi - (ngon_b * floor($a/ngon_b));
      if(ngon_phi > ngon_b * 0.5) ngon_phi -= ngon_b;
    result: ($ngon_corners * (1.0 / (cos(ngon_phi) + EPS) - 1.0) + $ngon_circle)/(ngon_r_factor + EPS) * ($v)

  curl:
    param:
      curl_c1: {}
      curl_c2: {}
    src: |-
      float curl_re = 1.0 + $curl_c1 * $x + $curl_c2 * ($x * $x - $y * $y);
      float curl_im = $curl_c1 * $y + 2.0 * $curl_c2 * $x * $y;
    result: vec2($x * curl_re + $y * curl_im, $y * curl_re - $x * curl_im) / (curl_re * curl_re + curl_im * curl_im)

  rectangles:
    param:
      rectangles_x: {}
      rectangles_y: {}
    result: |-
      vec2(
        ($rectangles_x == 0)? $x: ((2 * floor($x/$rectangles_x) + 1.0) * $rectangles_x - $x),
        ($rectangles_y == 0)? $y: ((2 * floor($y/$rectangles_y) + 1.0) * $rectangles_y - $y)
      )
  
  arch:
    src: |-
      vec2 arch_sc = sincos(randf() * $weight * PI);
    result: vec2(arch_sc.x, arch_sc.x * arch_sc.x / arch_sc.y)

  tangent:
    result: vec2(sin($x)/cos($y), tan($y))

  square:
    result: vec2(randf() - 0.5, randf() - 0.5)

  rays:
    src: |-
      float rays_ang = $weight * randf() * PI;
      float rays_r = $weight / ($rsq + EPS);
    result: tan(rays_ang) * rays_r * vec2(cos($x), sin($y))

  blade:
    src: |-
      vec2 blade_sc = sincos(randf() * $weight * $r);
    result: vec2($x * (blade_sc.y + blade_sc.x), $x * (blade_sc.y - blade_sc.x))

  secant2:
    src: |-
      float secant2_cr = cos($weight * $r);
      float secant2_icr = 1.0/secant2_cr;
    result: "vec2($x, secant2_icr + ((secant2_cr < 0)? 1: -1))"

  twintrian:
    src: |-
      vec2 twint_sc = sincos(randf() * $weight * $r);
      float twint_diff = log10(twint_sc.x * twint_sc.x) + twint_sc.y;
      if(badval(diff)) diff = -30.0;
    result: vec2( $x * twint_diff, $x * (twint_diff - twint_sc.x * PI))

  cross:
    src: |-
      float cross_s = $x * $x - $y * $y;
    result: $v * sqrt(1.0/(cross_s * cross_s + EPS))
  # End normal variation work

  pre_blur:
    flags: [pre_xform]
    result: (randf() + randf() + randf() + randf() - 2.0) * sincos(randf() * 2.0 * PI).yx

  waves2:
    param:
      waves2_scalex: {}
      waves2_scaley: {}
      waves2_freqx: {}
      waves2_freqy: {}
    result: |-
      vec2(
        $x + $waves2_scalex * sin($y * $waves2_freqx),
        $y + $waves2_scaley * sin($x * $waves2_freqy)
      )

  cylinder:
    result: vec2(sin($x), $y)

  super_shape:
    param:
      super_shape_n1: {}
      super_shape_n2: {}
      super_shape_n3: {}
      super_shape_m: {}
      super_shape_holes: {}
      super_shape_rnd: {}
    src: |-
      vec2 super_shape_sc = sincos($super_shape_m * 0.25 * $phi + PI * 0.25);
    result: $v * (mix($r, randf(), $super_shape_rnd) - $super_shape_holes) * pow(pow(abs(super_shape_sc.y), $super_shape_n2)+pow(abs(super_shape_sc.x), $super_shape_n3), -1.0 / $super_shape_n1) / $r




